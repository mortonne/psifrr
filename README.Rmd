---
output: github_document
---

<!-- README.md is generated from README.Rmd. Please edit that file -->

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.path = "man/figures/README-",
  out.width = "100%"
)
```

# psifrr <img src="man/figures/logo.png" width="150px" align="right" />
<!-- badges: start -->
<!-- badges: end -->

Analysis and visualization of free recall data.

psifrr relies on the [Psifr](https://psifr.readthedocs.io/en/stable/index.html) Python package, which is called from R using the `reticulate` package.

## Installation

First, install `devtools` and `reticulate`:

``` r
install.packages("reticulate")
install.packages("devtools")
```

Follow the `reticulate` package [documentation](https://rstudio.github.io/reticulate/index.html) to set up a Python environment.

Next, install the Psifr Python package:

``` r
py_install("git+https://github.com/mortonne/psifr.git@reticulate", pip=TRUE)
```

Finally, install psifrr from [GitHub](https://github.com/) with:

``` r
devtools::install_github("mortonne/psifrr")
```

## Working with free recall data

To load a sample dataset in [Psifr format](https://psifr.readthedocs.io/en/stable/guide/import.html):

```{r}
library(psifrr)
raw <- sample_data("Morton2013")
head(raw)
```

To analyze a dataset, we need to first score it by matching up study items to recalled items.
See [Scoring data](https://psifr.readthedocs.io/en/stable/guide/score.html) for details.

```{r}
data <- merge_free_recall(raw)
```

We can use `filter_data` to a select one list for a sample of what the results look like:

```{r}
filter_data(data, subjects = 1, lists = 1)
```

See [Managing data](https://psifr.readthedocs.io/en/latest/api/fr.html#managing-data)
for a full list of functions that operate on free recall data.

## Recall performance

### Serial position curve

We can calculate average recall for each serial position using `spc`.

```{r}
recall <- spc(data)
head(recall)
```

### Probability of Nth recall

We can also split up recalls, to test for example how likely participants were to initiate recall with the last item on the list, using `pnr`.

```{r}
nth_recall <- pnr(data)
head(nth_recall)
```

This gives us the probability of recall conditional on both output position (`output`) and serial or input position (`input`).

### Prior-list intrusions

Participants will sometimes accidentally recall items from prior lists; these recalls are known as prior-list intrusions (PLIs). To better understand how prior-list intrusions are happening, you can look at how many lists back those items were originally presented using `pli_list_lag`.

First, you need to choose a maximum list lag that you will consider. This determines which lists will be included in the analysis. For example, if you have a maximum lag of 3, then the first 3 lists will be excluded from the analysis. This ensures that each included list can potentially have intrusions of each possible list lag.

```{r}
pli <- pli_list_lag(data, max_lag = 3)
head(pli)
```

The analysis returns a raw count of intrusions at each lag (`count`), the count divided by the number of included lists (`per_list`), and the probability of a given intrusion coming from a given lag (`prob`).
